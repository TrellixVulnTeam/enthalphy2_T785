module cholesky_integrals_class
!
   type cholesky_integrals
      integer           :: n_J       = 0
      integer           :: n_ao      = 0
      integer           :: n_mo      = 0
      character(len=10) :: integral_program
   contains
!	
      procedure :: init => init_cholesky_integrals
!
   end type cholesky_integrals
!
contains
!
   subroutine init_cholesky_integrals(cholesky)
!
      implicit none
!
      class(cholesky_integrals)   :: cholesky
!
      cholesky % integral_program = 'DALTON    '
!
      if (cholesky % integral_program .eq. 'DALTON    ') then
!
         call dalton_interface_driver(cholesky)
!
      endif
!
   end subroutine init_cholesky_integrals
!
   subroutine dalton_interface_driver(cholesky)
!
!     Dalton Interface Driver
!     Written by Sarai D. Folkestad and Eirik F. Kj√∏nstad, 20 Apr 2017
!
!     Reads the AO Cholesky vectors from file generated by Dalton,
!     transforms the vectors to the MO basis, and saves the MO vectors
!     to file
!
      use input_output
      use workspace
      use mlcc_oo_utilities
!
      implicit none
!
      class(cholesky_integrals) :: cholesky
!
      integer                   :: unit_cholesky_ao    = -1
      integer                   :: unit_cholesky_mo_ij = -1
      integer                   :: unit_cholesky_mo_ia = -1
      integer                   :: unit_cholesky_mo_ab = -1
!
      integer                   :: n_ao_sq_packed      = 0
!
      real(dp), dimension(:,:), allocatable :: cholesky_ao
      real(dp), dimension(:,:), allocatable :: cholesky_ao_sq
      real(dp), dimension(:,:), allocatable :: cholesky_mo_sq
!
      real(dp), dimension(:,:), allocatable :: X
!
!     Getting identifier for AO integrals file    
!
      call generate_unit_identifier(unit_cholesky_ao)
!
      n_ao_sq_packed = packed_size(cholesky%n_ao)
!
!     Open Dalton file MLCC_CHOLESKY (see mlcc_write_cholesky.F)
! 
      open(unit=unit_cholesky_ao,file='mlcc_cholesky',status='old',form='formatted')
      rewind(unit_cholesky_ao)
!
!     Read the number of Cholesky vectors, n_J
!
      read(unit_cholesky_ao,*) cholesky%n_J
      write(unit_output,*) 'The number of Cholesky vectors:', cholesky%n_J
!
!     Open files for MO Cholesky vectors 
!
      call generate_unit_identifier(unit_cholesky_mo_ij)
      call generate_unit_identifier(unit_cholesky_mo_ia)
      call generate_unit_identifier(unit_cholesky_mo_ab)
!
      open(unit_cholesky_mo_ij,file='cholesky_ij',status='new',form='unformatted')
      rewind(unit_cholesky_mo_ij)
!
      open(unit_cholesky_mo_ia,file='cholesky_ia',status='new',form='unformatted')
      rewind(unit_cholesky_mo_ia)
!
      open(unit_cholesky_mo_ab,file='cholesky_ab',status='new',form='unformatted')
      rewind(unit_cholesky_mo_ab)
!
!     Allocate packed and unpacked Cholesky AO, and 
!     unpacked Cholesky MO vectors
!
      call allocator(cholesky_ao,n_ao_sq_packed,1)
      call allocator(cholesky_ao_sq,cholesky%n_ao,cholesky%n_ao)
      call allocator(cholesky_mo_sq,cholesky%n_mo,cholesky%n_mo)
!
      cholesky_ao    = zero
      cholesky_ao_sq = zero
      cholesky_mo_sq = zero
!
!     Allocate an intermediate, X
!
      call allocator(X,cholesky%n_ao,cholesky%n_mo)
!
      X = zero
!
!     Loop over the number of Cholesky vectors,
!     reading them one by one 
!
! .... TODO
!
! !
! !========================================
! !
! ! Preparation of files for cholesky in MO basis:
! ! ij-type:
!   lucho_ij = -1
!   call gpopen(lucho_ij,'CHOLESKY_IJ','UNKNOWN','SEQUENTIAL','UNFORMATTED',idum,.false.)
!   rewind(lucho_ij)
! ! ai-type:
!   lucho_ia = -1
!   call gpopen(lucho_ia,'CHOLESKY_IA','UNKNOWN','SEQUENTIAL','UNFORMATTED',idum,.false.)
!   rewind(lucho_ia)
! ! ab-type:
!   lucho_ab = -1
!   call gpopen(lucho_ab,'CHOLESKY_AB','UNKNOWN','SEQUENTIAL','UNFORMATTED',idum,.false.)
!   rewind(lucho_ab)
!  
   end subroutine dalton_interface_driver
!
end module cholesky_integrals_class
